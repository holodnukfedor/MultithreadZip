# MultithreadZip
Многопоточное выполнение архивации по блокам с помощью .NET 3.5

Данный проект выполнялся как тестовое задание, прошу проверяющему обязательно прочести мои комметарии к решению

# Задача

Написать консольную программу на C#, предназначенную для поблочного сжатия и
расжатия файлов с помощью System.IO.Compression.GzipStream.
Для компрессии исходный файл делится на блоки одинакового размера, например, в 1
мегабайт. Каждый блок компрессится и записывается в выходной файл независимо от
остальных блоков.
Программа должна эффективно распараллеливать и синхронизировать обработку блоков 
в многопроцессорной среде и уметь обрабатывать файлы, размер которых превышает
объем доступной оперативной памяти.
В случае исключительных ситуаций необходимо проинформировать пользователя
понятным сообщением, позволяющим пользователю исправить возникшую проблему, в
частности если проблемы связаны с ограничениями операционной системы.
При работе с потоками допускается использовать только стандартные классы и
библиотеки из .Net 3.5 (исключая ThreadPool, BackgroundWorker, TPL). Ожидается
реализация с использованием Thread-ов.
Код программы должен соответствовать принципам ООП и ООД (читаемость, разбиение
на классы и т.д.).
Параметры программы, имена исходного и результирующего файлов должны задаваться
в командной строке следующим образом:
GZipTest.exe compress/decompress [имя исходного файла] [имя результирующего файла]

# Комментарии к решению
Архитектура программы построена на паттерне шаблонный метод, который имеет классы для операций чтения и записи, обработки блоков данных.
Что позволит повторно использовать код. Например можно изменить обработки из архивации с помощью GZIPStream на любое другую обработку данных.

Перед записью заархивированного блока записывается его размер, чтобы можно было его быстро считать. 
Это делает несовместимым выходной архив с обычными архиваторами. 
Чтобы сделать его совместимым, нужно записывать блоки без длины и определять размер блока данных в архиве с помощью первых трех чисел 
(Два магические числа идентификаторы архива Gzip, третье метод архивации Deflate, который используется GZipStream).
Проверять эти числа нужно в цикле на протяжении всего потока, что замедлит обработку. 
Также невыгодно читать по одному байту, а читать в буфер и проверки выполнять в нем. В задаче не было сказано о совместимости, 
если нужно допишу. Шаблонный метод позволит мне сделать это почти не затрагивая остального кода программы.

В наличии потоки: потоки обработчики данных количеством равные кол. процессоров, 1 поток на чтение данных и 1 поток на запись даннных. 
Чтобы не возникло OutOfMemoryException и не использовалась виртуальная память (из-за ее использования простаивает процессор) 
размеры очередей блоков данных потоков обработчиков и хеш-таблицы ограничены. Значение максимально допустимого размера коллекций выбрано эмпирически. Поскольку не удалось быстро рассчитать размеры коллекций без использования виртуальной оперативной памяти.
Если коллекции достигают своего предела поток чтения даных ожидает на событии. 

Чтение и запись производится синхронно по 1 Мб при чтении (при записи в зависимости от выхода процесса обработки). 
При тестировании обнаружено, чтобы при асинхронном вводе/выводе обработка происходить медленней 
из-за частых переключений контекста и выбора потока обработки из CLR. Можно попробовать читать большие блоки данных, а потом уже разбивать их.
Но этот метод не проверялся ради экономии времени разработки. Если будет необходимо допишу и протестирую.

Во время работы алгоритма выводится номер записываемого блока, он показывает, что программа работает. 
